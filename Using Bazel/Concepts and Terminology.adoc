= Concepts and Terminology

概念 和 术语

This document provides an overview of the source tree layout and the terminology used in Bazel.

这个文档提供一个概览：代码组织和术语


= Table of Contents
目录

* Introduction
* Workspace, Packages and Targets
** Workspace （带WORKSPACE的目录）
** Packages （带BUILD的目录）
** Targets （文件，不论直接指代，还是函数指代）
** Labels （路径，只能指到target，不能指到pacakge。//<pacakge>:<target>）
** Lexical Specifications of a Label （路径词法：target文件部分和package目录部分）
** Rules （规则，文件的函数指代）
* BUILD Files
** The Core Build Language
** Declaring Build Rules
* Types of Build Rules
* Dependencies
** Actual and Declared Dependencies
** Types of Dependencies
** Using Labels to Reference Directories


= Introduction
介绍

Bazel builds software from source code organized in a directory called a workspace. Source files in the workspace are organized in a nested hierarchy of packages, where each package is a directory that contains a set of related source files and one BUILD file. The BUILD file specifies what software outputs can be built from the source.

bazel编译软件从源代码，这个源代码是在一个目录里面，这个目录叫做workspace。

workspace里面是按照嵌套的package组织的，每个package其实也是一个目录，特别的是这个目录被一个BUILD文件标识。（我理解的，每个BUILD就代表了这个package，没有BUILD文件的目录不是package？）

这个BUILD文件说明源代码的编译结果是啥。

= Workspace, Packages and Targets
工作区，包，目标

== Workspace
工作区 （带WORKSPACE的目录）

A workspace is a directory on your filesystem that contains the source files for the software you want to build, as well as symbolic links to directories that contain the build outputs. Each workspace directory has a text file named WORKSPACE which may be empty, or may contain references to external dependencies required to build the outputs. See also the Workspace Rules section in the Build Encyclopedia.

一个工作区就是一个目录，这个目录包括源文件 和 指向编译结果的链接

工作区目录是一个叫WORKSPACE的文件标识的。

这个WORKSPACE文件可以是空的，或者写一些外部依赖在里面。（参考Build Encyclopedia章的Workspace Rules节）

== Packages
包 （带BUILD的目录）

The primary unit of code organization in a workspace is the package. A package is collection of related files and a specification of the dependencies among them.

workspace里面代码组织的 基本单元 是 package

一个 package 是一个集合，集合里面是文件和依赖的说明。

A package is defined as a directory containing a file named BUILD, residing beneath the top-level directory in the workspace. A package includes all files in its directory, plus all subdirectories beneath it, except those which themselves contain a BUILD file.

一个package就是一个目录，只是这个目录里有个BUILD文件，这个目录是workspace目录的子目录

一个package包含所有目录里面的文件和递归子目录，除了那些自己是package的子目录以外。（意思就是package里面还有package，上层package包含除了下层package以外的所有其他内容）

For example, in the following directory tree there are two packages, my/app, and the subpackage my/app/tests. Note that my/app/data is not a package, but a directory belonging to package my/app.

看个例子，有2个package（因为有2个BUILD），my app 和 my app tests

注意，my app data 不是一个package，它只是 my app的一部分。

src/my/app/BUILD

src/my/app/app.cc

src/my/app/data/input.txt

src/my/app/tests/BUILD

src/my/app/tests/test.cc

== Targets
目标

A package is a container. The elements of a package are called targets. Most targets are one of two principal kinds, files and rules. Additionally, there is another kind of target, package groups, but they are far less numerous.

一个package是一个容器，容器里面的 元素／成员 叫做 target。

大部分 target 是2种类型，files或者rules。另一种类型叫 package group，但是很少见。（file是数据，rule是函数；引用函数 就是使用 函数的 输出 数据）

=== file 数据

Files are further divided into two kinds. Source files are usually written by the efforts of people, and checked in to the repository. Generated files, sometimes called derived files, are not checked in, but are generated by the build tool from source files according to specific rules.

files类型再分为2种：程序员写的源代码（source file），和工具生成的文件（generated file／derived file）。

=== rule 函数

The second kind of target is the rule. A rule specifies the relationship between a set of input and a set of output files, including the necessary steps to derive the outputs from the inputs. The outputs of a rule are always generated files. The inputs to a rule may be source files, but they may be generated files also; consequently, outputs of one rule may be the inputs to another, allowing long chains of rules to be constructed.

rule有输入file和输出file，rule是步骤从输入file到输出file。

rule的输出file一定是generated file/derived file。

rule的输入file可以是source file或者generated file。

这样rule可以串起来。

Whether the input to a rule is a source file or a generated file is in most cases immaterial; what matters is only the contents of that file. This fact makes it easy to replace a complex source file with a generated file produced by a rule, such as happens when the burden of manually maintaining a highly structured file becomes too tiresome, and someone writes a program to derive it. No change is required to the consumers of that file. Conversely, a generated file may easily be replaced by a source file with only local changes.

rule的输入file是source还是generated不重要，重要的是file内容。所以可以用一个rule来生成generated而不用手工维护一个source。这个rule对使用rule输出file的其他rule来说是看不见的，所以它们可以不用动。

这个过程也可以反过来，用source来替换generated。

The inputs to a rule may also include other rules. The precise meaning of such relationships is often quite complex and language- or rule-dependent, but intuitively it is simple: a C++ library rule A might have another C++ library rule B for an input. The effect of this dependency is that the B's header files are available to A during compilation, B's symbols are available to A during linking, and B's runtime data is available to A during execution.

rule串起来以后可以变得复杂，而且是语言或者rule依赖的。但是直观的很好理解，一个rule A依赖rule B，那么编译时A可以用B的头文件，链接时A可以用B的符号，运行时A可以用B的数据。

An invariant of all rules is that the files generated by a rule always belong to the same package as the rule itself; it is not possible to generate files into another package. It is not uncommon for a rule's inputs to come from another package, though.

不变式：rule的输出file还是属于同一个package。（也就是说一个package的rule不能写到其他package的目录里面去）

=== package group

Package groups are sets of packages whose purpose is to limit accessibility of certain rules. Package groups are defined by the *package_group* function. They have two properties: the list of packages they contain and their name. The only allowed ways to refer to them are from the *visibility* attribute of rules or from the *default_visibility* attribute of the *package* function; they do not generate or consume files. For more information, refer to the appropriate section of the Build Encyclopedia.

package group就是package的集合，目的是为了限制某些rule的访问。

== Labels
标签

All targets belong to exactly one package. The name of a target is called its label, and a typical label in canonical form looks like this:

target属于一个package。target的路径就是它的label，一个典型的label用canonical的格式就像这样：

  //my/app/main:app_binary

Each label has two parts, a package name (my/app/main) and a target name (app_binary). Every label uniquely identifies a target. Labels sometimes appear in other forms; when the colon is omitted, the target name is assumed to be the same as the last component of the package name, so these two labels are equivalent:

每个label有2个部分，package名字和target名字。（注意这里的package名字没有最开头的//。//可以理解成workspace根？）

每个label唯一定位一个target。

label还有其他格式，当冒号后面省略的时候，意思就是说target名字就是package名字最后一节一样。像下面这两个等价：

* //my/app
* //my/app:app

Short-form labels such as //my/app are not to be confused with package names. Labels start with //, but package names never do, thus my/app is the package containing //my/app. (A common misconception is that //my/app refers to a package, or to all the targets in a package; neither is true.)

这种短格式的label不会跟package名字混淆。因为label用//开头，但是package名字没有//开头。所以my/app是一个package目录，它含有//my/app这个target文件。

常见错误：//my/app是一个package（其实它是一个target，应为有//开头，省略冒号）

常见错误：//my/app指代所有target（其实它只指代一个target，就是省略冒号的那个同名target）

Within a BUILD file, the package-name part of label may be omitted, and optionally the colon too. So within the BUILD file for package my/app (i.e. //my/app:BUILD), the following "relative" labels are all equivalent:

在一个BUILD文件内，可以省略package名字，冒号也可以省略。（因为都是同package的target的时候。）下面这些等价：

* //my/app:app  完整路径 = //<package>:<target>
* //my/app  完整路径，这是同名省略冒号
* :app  相对路径，这是rule输出file
* app  相对路径，这是直接file

(It is a matter of convention that the colon is omitted for files, but retained for rules, but it is not otherwise significant.)

大家一般约定俗成：file省略冒号，rule保留冒号。但这不是语法。

Similarly, within a BUILD file, files belonging to the package may be referenced by their unadorned name relative to the package directory:

在一个BUILD内，file用裸名字，相对自己package路径指代：

  generate.cc
  testdata/input.txt

But from other packages, or from the command-line, these file targets must always be referred to by their complete label, e.g. //my/app:generate.cc.

但是在其他pcakge目录，或者命令行，file要用完整绝对路径

Relative labels cannot be used to refer to targets in other packages; the complete package name must always be specified in this case. For example, if the source tree contains both the package my/app and the package my/app/testdata (i.e., each of these two packages has its own BUILD file). The latter package contains a file named testdepot.zip. Here are two ways (one wrong, one correct) to refer to this file within //my/app:BUILD:

相对路径不能指代别人pacakge目录里面的target，这种情况下要用绝对路径。举个例子。。。

  testdata/testdepot.zip  # Wrong: testdata is a different package. 别人package不能用相对路径
  //my/app/testdata:testdepot.zip  # Right. 别人pacakge要用绝对路径

If, by mistake, you refer to testdepot.zip by the wrong label, such as //my/app:testdata/testdepot.zip or //my:app/testdata/testdepot.zip, you will get an error from the build tool saying that the label "crosses a package boundary". You should correct the label by putting the colon after the directory containing the innermost enclosing BUILD file, i.e., //my/app/testdata:testdepot.zip.

如果你犯错，会得到一个报错。

冒号总是最后一个BUILD关联的分隔符

== Lexical specification of a label
路径的词法

The syntax of labels is intentionally strict, so as to forbid metacharacters that have special meaning to the shell. This helps to avoid inadvertent quoting problems, and makes it easier to construct tools and scripts that manipulate labels, such as the Bazel Query Language. All of the following are forbidden in labels: any sort of white space, braces, brackets, or parentheses; wildcards such as *; shell metacharacters such as >, & and |; etc. This list is not comprehensive; the precise details are below.

路径的词法比较严格。这种严格是为了其他的地方方便。比如这些是不能在路径里面的，空白，括号，星号，shell不能用的符号等。详解如下

=== Target names, //...:target-name
target路径，文件路径

*target-name* is the name of the target within the package. 

上面那个target-name是相对BUILD目录来说的

The name of a rule is the value of the name parameter in the rule's declaration in a BUILD file; the name of a file is its pathname relative to the directory containing the BUILD file. 

rule的名字是BUILD定义rule的时候定义的。file的名字就是file自己的名字

Target names must be composed entirely of characters drawn from the set a–z, A–Z, 0–9, and the punctuation symbols _/.+-=,@~. 

合法的target名字可以包含 bla bla

Do not use .. to refer to files in other packages; use //packagename:filename instead. Filenames must be relative pathnames in normal form, which means they must neither start nor end with a slash (e.g. /foo and foo/ are forbidden) nor contain multiple consecutive slashes as path separators (e.g. foo//bar). Similarly, up-level references (..) and current-directory references (./) are forbidden. The sole exception to this rule is that a target name may consist of exactly '.'.

不要用.. 不要用/开头或者结尾 不要用// 不要用./ 

唯一例外是target名字里面就是有.

While it is common to use / in the name of a file target, we recommend that you avoid the use of / in the names of rules. Especially when the shorthand form of a label is used, it may confuse the reader. The label //foo/bar/wiz is always a shorthand for //foo/bar/wiz:wiz, even if there is no such package foo/bar/wiz; it never refers to //foo:bar/wiz, even if that target exists.

因为直接file的名字里面可能有/，所以建议rule的名字里面不要用/（约定俗成），避免迷惑读者。所以用短格式的label时，就只考虑最后一节的冒号重复，不用考虑带/的冒号重复。

However, there are some situations where use of a slash is convenient, or sometimes even necessary. For example, the name of certain rules must match their principal source file, which may reside in a subdirectory of the package.

但是有些时候rule名字带/也是说得通的，比如这些rule要指代子目录里面的file等。（这文章作者前后打脸）

=== Package names, //package-name:...
package名字

The name of a package is the name of the directory containing its BUILD file, relative to the top-level directory of the source tree. For example: my/app. Package names must be composed entirely of characters drawn from the set A-Z, a–z, 0–9, '/', '-', '.', and '_', and cannot start with a slash.

pacakge的名字就是目录的名字，相对workspace根。pacakge目录名字必须是 bla bla，不能用/开头。

For a language with a directory structure that is significant to its module system (e.g. Java), it is important to choose directory names that are valid identifiers in the language.

对于比如java这种对目录结构严格要求的，（就是要满足java和bazel同时）

Although Bazel allows a package at the build root (e.g. //:foo), this is not advised and projects should attempt to use more descriptively named packages.

尽管可以在workspace根里带一个BUILD，但是不建议

Package names may not contain the substring //, nor end with a slash.

package名字不能带//，也不能/结尾

== Rules
规则

A rule specifies the relationship between inputs and outputs, and the steps to build the outputs. Rules can be of one of many different kinds or classes, which produce compiled executables and libraries, test executables and other supported outputs as described in the Build Encyclopedia.

rule从输入到输出

Every rule has a name, specified by the name attribute, of type string. The name must be a syntactically valid target name, as specified above. In some cases, the name is somewhat arbitrary, and more interesting are the names of the files generated by the rule; this is true of genrules. In other cases, the name is significant: for *_binary and *_test rules, for example, the rule name determines the name of the executable produced by the build.

rule有个string类型的名字属性，这个名字要符合前面讲的target的名字。有些情况下，rule名字随意，有些会影响输出file的名字，有些rule名字有专门含义，比如binary和test

Every rule has a set of attributes; the applicable attributes for a given rule, and the significance and semantics of each attribute are a function of the rule's class; see the Build Encyclopedia for the full list of supported rules and their corresponding attributes. Each attribute has a name and a type. The full set of types that an attribute can have is: integer, label, list of labels, string, list of strings, output label, list of output labels. Not all attributes need to be specified in every rule. Attributes thus form a dictionary from keys (names) to optional, typed values.

除了名字属性外，rule还有一把属性，

每个属性都有一个名字和类型。类型可以是integer，[label，label list]，[string，string list]，[output label，output label list]。（整型，输入？路径，字符串，输出路径）

The srcs attribute present in many rules has type "list of label"; its value, if present, is a list of labels, each being the name of a target that is an input to this rule.

srcs属性常见，表示输入file，是lable list类型。

The outs attribute present in many rules has type "list of output labels"; this is similar to the type of the srcs attribute, but differs in two significant ways. Firstly, due to the invariant that the outputs of a rule belong to the same package as the rule itself, output labels cannot include a package component; they must be in one of the "relative" forms shown above. Secondly, the relationship implied by an (ordinary) label attribute is inverse to that implied by an output label: a rule depends on its srcs, whereas a rule is depended on by its outs. The two types of label attributes thus assign direction to the edges between targets, giving rise to a dependency graph.

outs属性常见，是out label list类型。特点：输出file属于跟rule同一个package，所以路径不带package，必须是相对路径；src target-rule-out target，关联两个target且有方向

This directed acyclic graph over targets is called the "target graph" or "build dependency graph", and is the domain over which the Bazel Query tool operates.

有向无环图，这是query的基础。

= BUILD Files
BUILD文件

The previous section described packages, targets and labels, and the build dependency graph abstractly. In this section, we'll look at the concrete syntax used to define a package.

这一节我们学习语法来定义package

By definition, every package contains a BUILD file, which is a short program written in the Build Language. Most BUILD files appear to be little more than a series of declarations of build rules; indeed, the declarative style is strongly encouraged when writing BUILD files.

pacakge对应一个BUILD用Build语言写的。大多数BUILD文件就是包含一列表rule，确实，这种声明式的样子是推荐的BUILD样子。

However, the build language is in fact an imperative language, and BUILD files are interpreted as a sequential list of statements. Build rule functions, such as cc_library, are procedures whose side-effect is to create an abstract build rule inside the build tool.

但是build语言是一种命令式语言，BUILD文件被解析成一序列的语句。rule函数创建了一个抽象的 bla（这个句子shi一样）

The concrete syntax of BUILD files is a subset of Python. Originally, the syntax was that of Python, but experience showed that users rarely used more than a tiny subset of Python's features, and when they did, it often resulted in complex and fragile BUILD files. In many cases, the use of such features was unnecessary, and the same result could be achieved by using an external program, e.g. via a genrule build rule.

BUILD的语法是python的子集。最开始就是python，但是后来发现大家只用python的一部分，如果用全python就会复杂和乱的。所以就是python的子集。如果要用更多python的部分可以用外挂的方式，比如genrule

Crucially, programs in the build language are unable to perform arbitrary I/O (though many users try!). This invariant makes the interpretation of BUILD files hermetic, i.e. dependent only on a known set of inputs, which is essential for ensuring that builds are reproducible.

BUILD语言不能做io，尽管有些用户想。这个不变式使得build变成密闭的系统，保证编译能重现

== The Core Build Language
核心build语言

Lexemes: the lexical syntax of the core language is a strict subset of Python 2.6, and we refer the reader to the Python specification for details. Lexical features of Python that are not supported include: floating-point literals, hexadecimal and Unicode escapes within string literals.

词法是python 2.6 严格子集。不支持的：浮点，十六进制，unicode

BUILD files should be written using only ASCII characters, although technically they are interpreted using the Latin-1 character set. The use of coding: declarations is forbidden.

BUILD应该只用ASCII，尽管可以latin-1。不能声明encoding？

Grammar: the grammar of the core language is shown below, using EBNF notation. Ambiguity is resolved using precedence, which is defined as for Python.

语法如下，EBNF标识。用优先级祛除歧义
[source,txt]
-------------
file_input ::= (simple_stmt? '\n')*  全文分行

simple_stmt ::= small_stmt (';' small_stmt)* ';'?   一行用分号分割

small_stmt ::= expr                       表达式
             | assign_stmt              或者 赋值

assign_stmt ::= IDENTIFIER assign_op expr     变量 = 表达式

assign_op ::= '=' | '+=' | '-=' | '*=' | '/=' | '%='    赋值 符号

expr ::= INTEGER                    整数
       | STRING+                    字符串
       | IDENTIFIER                 变量
       | expr '(' arg_list? ')'     表达式/函数（参数 列表）
       | expr '.' IDENTIFIER        表达式/对象 变量
       | '[' expr_list? ']'         [表达式 列表]
       | '[' expr ('for' IDENTIFIER 'in' expr | 'if' expr)+ ']'     [表达式 列表 带for或者if]
       | '(' expr_list? ')'         (表达式 列表)
       | '{' dict_entry_list? '}'   {字典 列表}
       | '{' dict_entry ('for' IDENTIFIER 'in' expr | 'if' expr)+ '}'    {字典 列表 带for或者if}
       | expr bin_op expr           表达式 二元算符 表达式
       | '-' expr                   表达式 求反
       | 'not' expr                 表达式 求非
       | expr '[' expr? ':' expr? ':' expr? ']'         表达式 [3阶]
       | expr '[' expr? ':' expr? ']'                   表达式 [2阶]
       | expr '[' expr ']'                              表达式 [1阶]

bin_op ::= '+' | '-' | '*' | '/' | '//' | '%' | '|'
         | 'and' | 'or' | '==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in'  二元算符

expr_list ::= (expr ',')* expr ','?     表达式 列表

dict_entry_list ::= (dict_entry ',')* dict_entry ','?      字典 列表

dict_entry ::= expr ':' expr     键值对

arg_list ::= (arg ',')* arg ','?   函数 参数 列表

arg ::= IDENTIFIER '=' expr  赋值
      | expr                 表达式
-------------

For each expression of the core language, the semantics are identical to the corresponding Python semantics, except in the following cases:

表达式与python语义一致，除了一下：

certain overloads of the binary % operator are not supported. Only the int % int and str % tuple forms are supported. Only the %s and %d format specifiers may be used; %(var)s is illegal.

%用法

Many Python features are missing: control-flow constructs (loops, conditionals, exceptions), basic datatypes (floating-point numbers, big integers), import and the module system, support for definition of classes, some Python's built-in functions. Function definitions and for statements are allowed only in extension files (.bzl). Available functions are documented in the library section.

缺失：流程控制，基本数据类型，模块系统，class，语言内建函数。函数定义和for语句只在.bzl文件允许。可用的函数参见 bla

== Declaring build rules
声明rule

The build language is an imperative language, so in general, order does matter: variables must be defined before they are used, for example. However, most BUILD files consist only of declarations of build rules, and the relative order of these statements is immaterial; all that matters is which rules were declared, and with what values, by the time package evaluation completes. So, in simple BUILD files, rule declarations can be re-ordered freely without changing the behavior.

build语言是命令式语言，所以要注意顺序

但是大部分BUILD只包含一些rule，所以顺序就不重要了？

BUILD file authors are encouraged to use comments liberally to document the role of each build target, whether it is intended for public use, and anything else that would help users and future maintainers, including a # Description: comment at the top, explaining the role of the package.

使用注释

The Python comment syntax of #... is supported. Triple-quoted string literals may span multiple lines, and can be used for multi-line comments.

用#和'''

= Types of build rule
rule类型

The majority of build rules come in families, grouped together by language. For example, cc_binary, cc_library and cc_test are the build rules for C++ binaries, libraries, and tests, respectively. Other languages use the same naming scheme, with a different prefix, e.g. java_* for Java. These functions are all documented in the Build Encyclopedia.

主要的rule按照编程语言分类。（java c++ python binary test library）

*_binary rules build executable programs in a given language. After a build, the executable will reside in the build tool's binary output tree at the corresponding name for the rule's label, so //my:program would appear at (e.g.) $(BINDIR)/my/program.

生成的在binary里面，比如 bla

Such rules also create a runfiles directory containing all the files mentioned in a data attribute belonging to the rule, or any rule in its transitive closure of dependencies; this set of files is gathered together in one place for ease of deployment to production.

这些binary会收集在一起，方便部署。用data属性标识路径

*_test rules are a specialization of a *_binary rule, used for automated testing. Tests are simply programs that return zero on success.

test是一种特殊的binary。test给出0当成功的时候

Like binaries, tests also have runfiles trees, and the files beneath it are the only files that a test may legitimately open at runtime. For example, a program cc_test(name='x', data=['//foo:bar']) may open and read $TEST_SRCDIR/workspace/foo/bar during execution. (Each programming language has its own utility function for accessing the value of $TEST_SRCDIR, but they are all equivalent to using the environment variable directly.) Failure to observe the rule will cause the test to fail when it is executed on a remote testing host.

跟随bin。收集的test才能被测试的时候访问

*_library rules specify separately-compiled modules in the given programming language. Libraries can depend on other libraries, and binaries and tests can depend on libraries, with the expected separate-compilation behavior.

库。bin和test可以依赖lib

= Dependencies
依赖

A target A depends upon a target B if B is needed by A at build or execution time. The depends upon relation induces a directed acyclic graph (DAG) over targets, and we call this a dependency graph. A target's direct dependencies are those other targets reachable by a path of length 1 in the dependency graph. A target's transitive dependencies are those targets upon which it depends via a path of any length through the graph.

编译的时候和运行的时候的依赖都叫依赖。依赖是target/文件的DAG。直接依赖，间接依赖

In fact, in the context of builds, there are two dependency graphs, the graph of actual dependencies and the graph of declared dependencies. Most of the time, the two graphs are so similar that this distinction need not be made, but it is useful for the discussion below.

有两种依赖DAG：actual和declared。尽管它们很相近。

== Actual and declared dependencies
acutal和declared依赖

A target X is actually dependent on target Y iff Y must be present, built and up-to-date in order for X to be built correctly. "Built" could mean generated, processed, compiled, linked, archived, compressed, executed, or any of the other kinds of tasks that routinely occur during a build.

actual：对象file必须在ready to build/run。（源代码里面的依赖）

A target X has a declared dependency on target Y iff there is a dependency edge from X to Y in the package of X.

declared：只是BUILD字面上的，不一定ready to build

For correct builds, the graph of actual dependencies A must be a subgraph of the graph of declared dependencies D. That is, every pair of directly-connected nodes x --> y in A must also be directly connected in D. We say D is an overapproximation of A.

为了正确编译，actual要是declared的子图。（也就是说BUILD必须完全，不能有超出预想的情况发生）

It is important that it not be too much of an overapproximation, though, since redundant declared dependencies can make builds slower and binaries larger.

但是BUILD完全也不是说要加很多不必要的在BUILD里面。

What this means for BUILD file writers is that every rule must explicitly declare all of its actual direct dependencies to the build system, and no more. Failure to observe this principle causes undefined behavior: the build may fail, but worse, the build may depend on some prior operations, or upon which transitive declared dependencies the target happens to have. The build tool attempts aggressively to check for missing dependencies and report errors, but it is not possible for this checking to be complete in all cases.

BUILD的rule要显式写明所有actual直接依赖。

You need not (and should not) attempt to list everything indirectly imported, even if it is "needed" by A at execution time.

不要写出所有的间接的 bla

During a build of target X, the build tool inspects the entire transitive closure of dependencies of X to ensure that any changes in those targets are reflected in the final result, rebuilding intermediates as needed.

编译过程中，bazel会检查间接依赖

The transitive nature of dependencies leads to a common mistake. Through careless programming, code in one file may use code provided by an indirect dependency, i.e. a transitive but not direct edge in the declared dependency graph. Indirect dependencies do not appear in the BUILD file. Since the rule doesn't directly depend on the provider, there is no way to track changes, as shown in the following example timeline:

源代码中可能有间接依赖，但是源代码间的这种关系并没有反应在BUILD中，因为BUILD只有直接依赖

1. At first, everything works

The code in package a uses code in package b. The code in package b uses code in package c, and thus a transitively depends on c.

[source,txt]
----
a/BUILD

rule(
    name = "a",  名字
    srcs = "a.in",  输入
    deps = "//b:b",  依赖
)

a/a.in

import b;  a依赖b
b.foo();

b/BUILD

rule(
    name = "b",
    srcs = "b.in",
    deps = "//c:c",
)

b/b.in

import c;
function foo() {
  c.bar();
}
----
Declared dependency graph:  a --> b --> c

Actual dependency graph:    a --> b --> c

The declared dependencies overapproximate the actual dependencies. All is well.


2. A latent hazard is introduced.

Someone carelessly adds code to a that creates a direct actual dependency on c, but forgets to declare it.

[source,txt]
----
a/a.in

import b;
import c;  a依赖c，但是a的BUILD不知道
b.foo();
c.garply();
----
Declared dependency graph:  a --> b --> c  BUILD里面的依赖

Actual dependency graph:    a --> b -->_c    源代码里面的依赖
                             \_________/|
                             
The declared dependencies no longer overapproximate the actual dependencies. This may build ok, because the transitive closures of the two graphs are equal, but masks a problem: a has an actual but undeclared dependency on c.

这种情况下可以build成功，因为间接依赖有。

3. The hazard is revealed

Someone refactors b so that it no longer depends on c, inadvertently breaking a through no fault of their own.

[source,txt]
----
b/BUILD

rule(
    name = "b",
    srcs = "b.in",
    deps = "//d:d",     a的BUILD里面没有写c，b的BUILD里面也没有c，这会让a的build失败找不到c
)

b/b.in

import d;
function foo() {
  d.baz();
}

----
Declared dependency graph:  a --> b     c       BUILD的

Actual dependency graph:    a --> b    _c       源代码的
                             \_________/|
                             
The declared dependency graph is now an underapproximation of the actual dependencies, even when transitively closed; the build is likely to fail. The problem could have been averted by ensuring that the actual dependency from a to c introduced in Step 2 was properly declared in the BUILD file.

BUILD要跟随 源代码，源代码是怎么依赖的，BUILD就要照着写是什么依赖

== Types of dependencies
依赖的类型

Most build rules have three attributes for specifying different kinds of generic dependencies: srcs, deps and data. These are explained below. See also Attributes common to all rules in the Build Encyclopedia.

大部分rule有3个属性：srcs，deps，data

Many rules also have additional attributes for rule-specific kinds of dependency, e.g. compiler, resources, etc. These are detailed in the Build Encyclopedia.

srcs dependencies

Files consumed directly by the rule or rules that output source files. 输入

deps dependencies

Rule pointing to separately-compiled modules providing header files, symbols, libraries, data, etc.  依赖

data dependencies

A build target might need some data files to run correctly. These data files aren't source code: they don't affect how the target is built. For example, a unit test might compare a function's output to the contents of a file. When we build the unit test, we don't need the file; but we do need it when we run the test. The same applies to tools that are launched during execution.

运行时要的数据，编译时不用

The build system runs tests in an isolated directory where only files listed as "data" are available. Thus, if a binary/library/test needs some files to run, specify them (or a build rule containing them) in data. For example:

test的时候只有data属性里面的文件才能被访问，test在一个隔离的目录里面。

[source,txt]
----
# I need a config file from a directory named env:
java_binary(
    name = "setenv",
    ...
    data = [":env/default_env.txt"],
)

# I need test data from another directory
sh_test(
    name = "regtest",
    srcs = ["regtest.sh"],
    data = [
        "//data:file1.txt",
        "//data:file2.txt",
        ...
    ],
)
----

These files are available using the relative path path/to/data/file. In tests, it is also possible to refer to them by joining the paths of the test's source directory and the workspace-relative path, e.g. ${TEST_SRCDIR}/workspace/path/to/data/file.

这些文件用相对路径

== Using Labels to Reference Directories
用label指向目录 （目录也是个文件）

As you look over our BUILD files, you might notice that some data labels refer to directories. These labels end with /. or / like so:

  data = ["//data/regression:unittest/."]  # don't use this

or like so:

  data = ["testdata/."]  # don't use this

or like so:

  data = ["testdata/"]  # don't use this

This seems convenient, particularly for tests (since it allows a test to use all the data files in the directory).

But try not to do this. In order to ensure correct incremental rebuilds (and re-execution of tests) after a change, the build system must be aware of the complete set of files that are inputs to the build (or test). When you specify a directory, the build system will perform a rebuild only when the directory itself changes (due to addition or deletion of files), but won't be able to detect edits to individual files as those changes do not affect the enclosing directory. Rather than specifying directories as inputs to the build system, you should enumerate the set of files contained within them, either explicitly or using the glob() function. (Use ** to force the glob() to be recursive.)

不要指向目录，因为这会让bazel难以检测是不是有代码变动。要显示列出要bazel检测的文件。用glob和**

  data = glob(["testdata/**"])  # use this instead

Unfortunately, there are some scenarios where directory labels must be used. For example, if the testdata directory contains files whose names do not conform to the strict label syntax (e.g. they contain certain punctuation symbols), then explicit enumeration of files, or use of the glob() function will produce an invalid labels error. You must use directory labels in this case, but beware of the concomitant risk of incorrect rebuilds described above.

但是有些时候只能指向目录，但是要知道坏处

If you must use directory labels, keep in mind that you can't refer to the parent package with a relative "../" path; instead, use an absolute path like "//data/regression:unittest/.".

不得不用目录的时候，不要用..

Note that directory labels are only valid for data dependencies. If you try to use a directory as a label in an argument other than data, it will fail and you will get a (probably cryptic) error message.

注意，目录只能用在data
